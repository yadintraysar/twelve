<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heavy-Duty IMU Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }

        .main-view {
            flex: 1;
            background: #2a2a2a;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            display: none;
        }

        .sidebar.visible {
            display: block;
        }

        .state-pill {
            display: inline-block;
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .state-still { 
            background: #28a745; 
            color: white; 
        }
        .state-tilting { 
            background: #ffc107; 
            color: black; 
        }
        .state-aggressive { 
            background: #dc3545; 
            color: white; 
        }
        .state-no-signal { 
            background: #6c757d; 
            color: white; 
        }

        .readouts {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .readout {
            background: #3a3a3a;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }

        .readout-label {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .readout-value {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            font-family: 'Courier New', monospace;
        }

        .controls {
            margin-bottom: 20px;
        }

        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #0056b3;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .corner-icons {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .icon-btn {
            width: 40px;
            height: 40px;
            background: rgba(128, 128, 128, 0.3);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            color: #ccc;
            font-size: 16px;
        }

        .icon-btn:hover {
            background: rgba(128, 128, 128, 0.5);
        }

        .hidden {
            display: none;
        }

        .advanced-panel {
            background: #3a3a3a;
            border-radius: 6px;
            padding: 15px;
            margin-top: 20px;
        }

        .advanced-panel.collapsed {
            display: none;
        }

        .setting-group {
            margin-bottom: 15px;
        }

        .setting-label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .setting-input {
            width: 100%;
            padding: 5px;
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 3px;
            color: white;
            font-size: 12px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .checkbox-group input {
            margin-right: 8px;
        }

        .no-signal-banner {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #dc3545;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: bold;
            z-index: 100;
            display: none;
        }

        .calibrating-banner {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: #ffc107;
            color: black;
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: bold;
            z-index: 100;
            display: none;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .info-text {
            font-size: 11px;
            color: #666;
            margin-top: 10px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-view">
            <canvas id="canvas"></canvas>
            <div id="noSignalBanner" class="no-signal-banner">No Signal</div>
            <!-- <div id="calibratingBanner" class="calibrating-banner">Calibrating...</div> -->
            
            <div class="corner-icons">
                <button id="dataToggleBtn" class="icon-btn" title="Toggle Data Panel">☰</button>
                <button id="settingsToggleBtn" class="icon-btn" title="Settings">⚙</button>
            </div>
        </div>
        
        <div id="sidebar" class="sidebar">
            <!-- <div id="statePill" class="state-pill state-still">Still</div> -->
            
            <div class="readouts">
                <div class="readout">
                    <div class="readout-label">Roll</div>
                    <div id="rollValue" class="readout-value">0.0°</div>
                </div>
                <div class="readout">
                    <div class="readout-label">Pitch</div>
                    <div id="pitchValue" class="readout-value">0.0°</div>
                </div>
                <div class="readout">
                    <div class="readout-label">Yaw</div>
                    <div id="yawValue" class="readout-value">0.0°</div>
                </div>
                <div class="readout">
                    <div class="readout-label">Gyro RMS</div>
                    <div id="gyroRmsValue" class="readout-value">0.0°/s</div>
                </div>
            </div>
            
            <div class="controls">
                <button id="recalibrateBtn" class="btn hidden">Re-zero</button>
            </div>
            
            <div id="advancedPanel" class="advanced-panel collapsed">
                <div class="setting-group">
                    <label class="setting-label">Tilt Thresholds (°)</label>
                    <input id="tiltThreshold" class="setting-input" type="number" value="8" step="0.5">
                    <input id="aggressiveThreshold" class="setting-input" type="number" value="15" step="0.5" style="margin-top: 5px;">
                </div>
                
                <div class="setting-group">
                    <label class="setting-label">Rate Thresholds (°/s)</label>
                    <input id="rateThreshold" class="setting-input" type="number" value="12" step="1">
                    <input id="aggressiveRateThreshold" class="setting-input" type="number" value="20" step="1" style="margin-top: 5px;">
                </div>
                
                <div class="setting-group">
                    <label class="setting-label">Smoothing τ (s)</label>
                    <input id="smoothingTau" class="setting-input" type="number" value="0.9" step="0.1" min="0.1" max="2.0">
                </div>
                
                <div class="checkbox-group">
                    <input id="showGravity" type="checkbox" checked>
                    <label for="showGravity">Show gravity arrow</label>
                </div>
                
                <div class="checkbox-group">
                    <input id="showAxes" type="checkbox" checked>
                    <label for="showAxes">Show axes labels</label>
                </div>
            </div>
            
            <div class="info-text">
                Heavy-duty IMU viewer for construction equipment. 
                Designed to ignore vibration and only show real tilt.
                <br><br>
                State thresholds are set high to avoid false triggers from equipment shake.
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        class IMUViewer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.cube = null;
                this.axes = null;
                this.gravityArrow = null;
                this.ws = null;
                this.controls = null;
                
                this.lastUpdate = 0;
                this.targetFPS = 20;
                this.frameInterval = 1000 / this.targetFPS;
                
                this.showGravity = false;  // Hide gravity arrow by default
                this.showAxes = true;
                
                // Initial rotation offset (identity: no yaw/pitch/roll offset)
                this.initialRotationOffset = new THREE.Quaternion();
                
                this.init();
                this.connectWebSocket();
                this.setupEventListeners();
            }
            
            init() {
                const canvas = document.getElementById('canvas');
                const container = canvas.parentElement;
                
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xaaaaaa); // Changed to lighter gray like script.js
                
                // Camera setup
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    container.clientWidth / container.clientHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0.67, 0.5, 0.67); // Much closer - 3x closer to device
                this.camera.lookAt(0, 0, 0);
                
                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    antialias: true 
                });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.setClearColor(0xaaaaaa); // Match background
                this.renderer.shadowMap.enabled = false; // Disable shadows

                // Orbit controls (user can orbit/pan/zoom the view)
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = false; // Disable damping to avoid floaty feel
                this.controls.dampingFactor = 0.08;
                this.controls.rotateSpeed = 0.5;
                this.controls.zoomSpeed = 0.6;
                this.controls.panSpeed = 0.6;
                this.controls.minDistance = 0.5; // Closer min distance for tunnel
                this.controls.maxDistance = 10; // Reduced max distance
                this.controls.target.set(0, 0, 0);
                
                // Create tunnel environment first
                this.createGround();
                this.createTunnel();
                
                // Load the 3D model (Pacman)
                this.loadModel();
                
                // Create coordinate axes
                this.createAxes();
                
                // Create gravity arrow (hidden by default)
                this.createGravityArrow();
                this.gravityArrow.visible = this.showGravity;
                
                // Lighting setup matching script.js
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 7.5);
                directionalLight.castShadow = false; // Disable shadow casting
                this.scene.add(directionalLight);
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Start render loop
                this.animate();
            }
            
            createGround() {
                console.log("Creating ground plane...");
                // Create ground plane (150m x 150m)
                const groundGeometry = new THREE.PlaneGeometry(150, 150);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x777777, // Gray concrete color from script.js
                    side: THREE.DoubleSide
                });
                this.groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
                this.groundMesh.rotation.x = -Math.PI / 2; // Rotate to be horizontal
                this.groundMesh.position.y = -0.01; // Slightly below origin
                this.groundMesh.receiveShadow = false;
                this.scene.add(this.groundMesh);
                console.log("Ground plane created");
            }
            
            createTunnel() {
                console.log("Creating arched inner tunnel...");
                
                // Inner tunnel dimensions (very tight fit for 60cm device)
                const tunnelWidth = 0.4; // 40cm - narrower than 60cm device
                const tunnelHeight = 0.7; // 70cm - more height clearance
                const tunnelLength = 8; // 8m long tunnel for good visual context
                
                // Tunnel material - sand colored, semi-transparent
                const tunnelMaterial = new THREE.MeshStandardMaterial({
                    color: 0x696969, // Sand color from script.js
                    roughness: 0.9,
                    metalness: 0.0,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.4 // Semi-transparent so we can see device inside
                });
                
                // Create arched tunnel profile (like in script.js)
                const profilePoints = [];
                const visualProfilePoints = 20;
                
                // Start with left bottom corner
                profilePoints.push(new THREE.Vector2(-tunnelWidth / 2, 0));
                
                // Create arched top using semicircle
                for (let i = 0; i <= visualProfilePoints; i++) {
                    const angle = Math.PI * (1 - i / visualProfilePoints);
                    profilePoints.push(new THREE.Vector2(
                        Math.cos(angle) * (tunnelWidth / 2), 
                        Math.sin(angle) * (tunnelWidth / 2) + (tunnelHeight - tunnelWidth / 2)
                    ));
                }
                
                // End with right bottom corner
                profilePoints.push(new THREE.Vector2(tunnelWidth / 2, 0));
                
                // Create simple straight path for our tunnel
                const pathPoints = [
                    new THREE.Vector3(0, 0, -tunnelLength/2),
                    new THREE.Vector3(0, 0, tunnelLength/2)
                ];
                
                // Create the tunnel geometry by extruding the profile along the path
                const visualPath = new THREE.CatmullRomCurve3(pathPoints);
                const pathSegments = 50; // Number of segments along the path
                const frames = visualPath.computeFrenetFrames(pathSegments, false);
                
                const tunnelVertices = [];
                const tunnelFaces = [];
                
                const worldUp = new THREE.Vector3(0, 1, 0);
                const rotationMatrix = new THREE.Matrix4();
                const translationMatrix = new THREE.Matrix4();
                const transformationMatrix = new THREE.Matrix4();
                const localVertex = new THREE.Vector3();
                const worldVertex = new THREE.Vector3();
                
                // Generate vertices by extruding profile along path
                for (let i = 0; i <= pathSegments; i++) {
                    const point = visualPath.getPointAt(i / pathSegments);
                    const tangent = frames.tangents[i];
                    
                    // Calculate local coordinate system
                    const axisZ = tangent.clone();
                    const axisX = worldUp.clone().cross(axisZ).normalize();
                    const axisY = axisZ.clone().cross(axisX).normalize();
                    
                    // Create transformation matrix
                    rotationMatrix.makeBasis(axisX, axisY, axisZ);
                    translationMatrix.makeTranslation(point.x, point.y, point.z);
                    transformationMatrix.multiplyMatrices(translationMatrix, rotationMatrix);
                    
                    // Transform each profile point
                    for (let j = 0; j < profilePoints.length; j++) {
                        const profilePoint = profilePoints[j];
                        localVertex.set(profilePoint.x, profilePoint.y, 0);
                        worldVertex.copy(localVertex).applyMatrix4(transformationMatrix);
                        tunnelVertices.push(worldVertex.x, worldVertex.y, worldVertex.z);
                    }
                    
                    // Generate faces
                    if (i > 0) {
                        const baseIdx = (i - 1) * profilePoints.length;
                        const currentBaseIdx = i * profilePoints.length;
                        for (let j = 0; j < profilePoints.length - 1; j++) {
                            const v1 = baseIdx + j;
                            const v2 = baseIdx + j + 1;
                            const v3 = currentBaseIdx + j + 1;
                            const v4 = currentBaseIdx + j;
                            tunnelFaces.push(v1, v2, v4);
                            tunnelFaces.push(v2, v3, v4);
                        }
                    }
                }
                
                // Create the tunnel geometry
                const tunnelGeometry = new THREE.BufferGeometry();
                tunnelGeometry.setAttribute('position', new THREE.Float32BufferAttribute(tunnelVertices, 3));
                tunnelGeometry.setIndex(tunnelFaces);
                tunnelGeometry.computeVertexNormals();
                
                // Create tunnel mesh
                const tunnelMesh = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
                tunnelMesh.castShadow = false;
                tunnelMesh.receiveShadow = false;
                
                // Create a group and add tunnel
                const tunnelGroup = new THREE.Group();
                tunnelGroup.add(tunnelMesh);
                
                // Add tunnel floor (separate from walls for better ground contact)
                const tunnelFloorGeometry = new THREE.PlaneGeometry(tunnelWidth, tunnelLength);
                const tunnelFloorMaterial = new THREE.MeshStandardMaterial({
                    color: 0x555555, // Slightly darker than main ground
                    roughness: 0.8
                });
                const tunnelFloor = new THREE.Mesh(tunnelFloorGeometry, tunnelFloorMaterial);
                tunnelFloor.rotation.x = -Math.PI / 2;
                tunnelFloor.position.y = 0.001; // Slightly above main ground
                tunnelFloor.receiveShadow = false;
                tunnelGroup.add(tunnelFloor);
                
                // Rotate the entire tunnel group 90 degrees around Y axis
                tunnelGroup.rotation.y = Math.PI / 2; // 90 degrees
                
                // Add the rotated tunnel group to the scene
                this.scene.add(tunnelGroup);
                
                console.log(`Arched tunnel created: ${tunnelWidth}m wide x ${tunnelHeight}m high x ${tunnelLength}m long`);
                console.log(`TIGHT FIT: Device width = 60cm, Tunnel width = ${tunnelWidth * 100}cm (device is ${((0.6 - tunnelWidth) * 100).toFixed(1)}cm WIDER than tunnel)`);
                console.log(`Height: Device ~30cm, Tunnel ${tunnelHeight * 100}cm (${((tunnelHeight - 0.3) * 100).toFixed(1)}cm clearance above device)`);
            }

            loadModel() {
                const loader = new GLTFLoader();
                console.log('Attempting to load pacman.glb...');
                
                loader.load(
                    'pacman2.glb',
                    (gltf) => {
                        // Success callback
                        console.log('GLTF loaded successfully:', gltf);
                        this.cube = gltf.scene;
                        
                        // Scale the model to be 60cm wide (as specified)
                        // First get current dimensions
                        const box = new THREE.Box3().setFromObject(this.cube);
                        const size = box.getSize(new THREE.Vector3());
                        const currentWidth = Math.max(size.x, size.z); // Use the larger horizontal dimension
                        
                        // Scale to make it 0.6m (60cm) wide
                        const targetWidth = 0.6;
                        const scaleFactor = targetWidth / currentWidth;
                        this.cube.scale.set(scaleFactor, scaleFactor, scaleFactor);
                        
                        // Position the model on the ground (tunnel floor)
                        const scaledBox = new THREE.Box3().setFromObject(this.cube);
                        const scaledSize = scaledBox.getSize(new THREE.Vector3());
                        
                        // Center horizontally, place on ground
                        this.cube.position.set(0, scaledSize.y / 2, 0);
                        this.cube.updateMatrixWorld(true);
                        
                        // Disable shadows for the model
                        this.cube.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = false;
                                child.receiveShadow = false;
                            }
                        });
                        
                        // Compute and cache local-space contact points (front, back, left, right centers at base)
                        // Derive local-space AABB by transforming world AABB corners back to local
                        const worldBox = new THREE.Box3().setFromObject(this.cube);
                        const worldMin = worldBox.min.clone();
                        const worldMax = worldBox.max.clone();
                        const worldCenter = worldBox.getCenter(new THREE.Vector3());
                        
                        // Convert world-space center/min/max to local space
                        const localCenter = this.cube.worldToLocal(worldCenter.clone());
                        const localMin = this.cube.worldToLocal(worldMin.clone());
                        const localMax = this.cube.worldToLocal(worldMax.clone());
                        const halfExtents = new THREE.Vector3(
                            Math.abs(localMax.x - localMin.x) / 2,
                            Math.abs(localMax.y - localMin.y) / 2,
                            Math.abs(localMax.z - localMin.z) / 2
                        );
                        const baseY = Math.min(localMin.y, localMax.y); // lowest local Y at base
                        
                        // Shrink factors to avoid using boom/tool overhang as footprint
                        const shrinkX = 0.75; // 75% of half-width toward center
                        const shrinkZ = 0.60; // 60% of half-depth toward center (pull front/back under legs)
                        const dx = halfExtents.x * shrinkX;
                        const dz = halfExtents.z * shrinkZ;
                        
                        this.contactLocalPoints = [
                            new THREE.Vector3(localCenter.x, baseY, localCenter.z + dz), // front center (shrunk)
                            new THREE.Vector3(localCenter.x, baseY, localCenter.z - dz), // back center (shrunk)
                            new THREE.Vector3(localCenter.x - dx, baseY, localCenter.z), // left center (shrunk)
                            new THREE.Vector3(localCenter.x + dx, baseY, localCenter.z)  // right center (shrunk)
                        ];
                        
                        // Apply initial rotation offset immediately
                        this.cube.quaternion.copy(this.initialRotationOffset);
                        
                        this.scene.add(this.cube);
                        
                        // Make orbit controls focus the model center
                        if (this.controls) {
                            const boxCenter = new THREE.Vector3();
                            new THREE.Box3().setFromObject(this.cube).getCenter(boxCenter);
                            this.controls.target.copy(boxCenter);
                            this.controls.update();
                        }
                        
                        console.log(`Model loaded and scaled to ${targetWidth}m width`);
                        console.log(`Device positioned in TIGHT tunnel environment`);
                        console.log(`Tight fit: Device = 60cm wide, Tunnel = 40cm wide (device is 20cm WIDER than tunnel)`);
                    },
                    (progress) => {
                        // Progress callback
                        console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
                    },
                    (error) => {
                        // Error callback - fallback to cube
                        console.error('Error loading Pacman model:', error);
                        console.log('Falling back to default cube');
                        this.createFallbackCube();
                    }
                );
            }
            
            createFallbackCube() {
                // Create a fallback cube that's 60cm wide (to match our scaling)
                const cubeGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.4); // 60cm x 30cm x 40cm
                const cubeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4a90e2,
                    transparent: true,
                    opacity: 0.8
                });
                this.cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                
                // Position on ground like the GLTF model
                this.cube.position.set(0, 0.15, 0); // Half height (30cm/2 = 15cm) above ground
                
                // Disable shadows
                this.cube.castShadow = false;
                this.cube.receiveShadow = false;
                
                this.scene.add(this.cube);
                console.log('Fallback cube created (60cm wide, positioned on ground in tunnel)');
            }
            
            createAxes() {
                this.axes = new THREE.Group();
                
                // Create dotted line material
                const createDottedLineMaterial = (color) => {
                    return new THREE.LineDashedMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.3,  // More transparent
                        dashSize: 0.1,
                        gapSize: 0.05
                    });
                };
                
                // X axis (light grey) - dotted line
                const xPoints = [new THREE.Vector3(-1, 0, 0), new THREE.Vector3(1, 0, 0)];
                const xGeometry = new THREE.BufferGeometry().setFromPoints(xPoints);
                const xMaterial = createDottedLineMaterial(0xcccccc);
                const xAxis = new THREE.Line(xGeometry, xMaterial);
                xAxis.computeLineDistances(); // Required for dashed lines
                this.axes.add(xAxis);
                
                // Y axis (white) - dotted line
                const yPoints = [new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 1, 0)];
                const yGeometry = new THREE.BufferGeometry().setFromPoints(yPoints);
                const yMaterial = createDottedLineMaterial(0xffffff);
                const yAxis = new THREE.Line(yGeometry, yMaterial);
                yAxis.computeLineDistances(); // Required for dashed lines
                this.axes.add(yAxis);
                
                // Z axis (medium grey) - dotted line
                const zPoints = [new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 0, 1)];
                const zGeometry = new THREE.BufferGeometry().setFromPoints(zPoints);
                const zMaterial = createDottedLineMaterial(0x999999);
                const zAxis = new THREE.Line(zGeometry, zMaterial);
                zAxis.computeLineDistances(); // Required for dashed lines
                this.axes.add(zAxis);
                
                this.scene.add(this.axes);
            }
            
            createGravityArrow() {
                this.gravityArrow = new THREE.Group();
                
                // Arrow shaft
                const shaftGeometry = new THREE.CylinderGeometry(0.03, 0.03, 1.5);
                const shaftMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.8
                });
                const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
                shaft.position.y = -0.75;
                this.gravityArrow.add(shaft);
                
                // Arrow head
                const headGeometry = new THREE.ConeGeometry(0.1, 0.3);
                const headMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.8
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = -1.65;
                this.gravityArrow.add(head);
                
                this.scene.add(this.gravityArrow);
            }
            
            connectWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.hostname}:6080`;
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('WebSocket connected');
                    this.hideNoSignal();
                };
                
                this.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.handleMessage(data);
                    } catch (e) {
                        console.error('Error parsing WebSocket message:', e);
                    }
                };
                
                this.ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    this.showNoSignal();
                    // Attempt to reconnect after 2 seconds
                    setTimeout(() => this.connectWebSocket(), 2000);
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.showNoSignal();
                };
            }
            
            handleMessage(data) {
                if (data.type === 'imu_data') {
                    this.updateVisualization(data);
                } else if (data.type === 'signal_lost') {
                    this.showNoSignal();
                }
            }
            
            updateVisualization(data) {
                try {
                    const now = Date.now();
                    if (now - this.lastUpdate < this.frameInterval) return;
                    this.lastUpdate = now;
                    
                    this.hideNoSignal();
                    
                    // Check if we have valid data
                    if (!data) {
                        console.warn('Received null or undefined data');
                        return;
                    }
                
                // Update state pill (commented out)
                // this.updateStatePill(data.state);
                
                // Update readouts
                document.getElementById('rollValue').textContent = `${data.euler.roll.toFixed(1)}°`;
                document.getElementById('pitchValue').textContent = `${data.euler.pitch.toFixed(1)}°`;
                document.getElementById('yawValue').textContent = `${data.euler.yaw.toFixed(1)}°`;
                document.getElementById('gyroRmsValue').textContent = `${data.gyroRMS.toFixed(1)}°/s`;
                
                // Update calibration banner (commented out)
                // if (data.isCalibrating) {
                //     this.showCalibrating();
                // } else {
                //     this.hideCalibrating();
                // }
                
                // Update cube orientation
                if (this.cube && data.quaternion && data.quaternion.x !== undefined) {
                    // Create quaternion from IMU data
                    const imuQuaternion = new THREE.Quaternion(
                        data.quaternion.x,
                        data.quaternion.y,
                        data.quaternion.z,
                        data.quaternion.w
                    );

                    // Rotate frame about Y to correct yaw mapping: q' = Ry(+90) * q * Ry(-90)
                    const ry90 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);
                    const ryNeg90 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), -Math.PI / 2);
                    const mappedQuat = new THREE.Quaternion();
                    mappedQuat.multiplyQuaternions(ry90, imuQuaternion); // Ry90 * q
                    mappedQuat.multiply(ryNeg90);                         // (Ry90 * q) * Ry-90

                    // Compose with initial offset (and invert to match desired direction)
                    const finalQuat = mappedQuat.clone().invert().multiply(this.initialRotationOffset);

                    // Reverse pitch only by negating Z in Euler (keep roll X and yaw Y unchanged)
                    const pitchOrder = 'YXZ';
                    const tmpEuler = new THREE.Euler().setFromQuaternion(finalQuat, pitchOrder);
                    // revert previous change: do not negate X
                    tmpEuler.z = -tmpEuler.z; // invert pitch mapped on Z
                    const adjustedQuat = new THREE.Quaternion().setFromEuler(tmpEuler);

                    // --- Pivot-anchored rotation ---
                    // Determine active pivot (lowest of the four contact points). Keep stable until the winning point changes by margin.
                    const groundY = 0.001;
                    const epsilon = 0.0005;
                    const hardBias = 0.002; // push slightly into ground for heavy feel
                    const targetMinY = groundY + epsilon - hardBias;

                    let pivotIndex = this.activePivotIndex ?? 0;
                    let minY = Infinity;
                    if (this.contactLocalPoints && this.contactLocalPoints.length === 4) {
                        let winner = 0;
                        for (let i = 0; i < 4; i++) {
                            const wp = this.cube.localToWorld(this.contactLocalPoints[i].clone());
                            if (wp.y < minY) { minY = wp.y; winner = i; }
                        }
                        // Hysteresis: only switch if the new winner is lower than current by a small margin
                        if (this.activePivotIndex === undefined) {
                            pivotIndex = winner;
                        } else {
                            const currentWp = this.cube.localToWorld(this.contactLocalPoints[this.activePivotIndex].clone());
                            if (minY < currentWp.y - 0.002) pivotIndex = winner; // 2mm margin
                        }
                        this.activePivotIndex = pivotIndex;
                    }

                    // Compute pivot world position BEFORE rotation
                    const pivotLocal = (this.contactLocalPoints && this.contactLocalPoints[pivotIndex])
                        ? this.contactLocalPoints[pivotIndex].clone()
                        : new THREE.Vector3(0, 0, 0);
                    const pivotWorldBefore = this.cube.localToWorld(pivotLocal.clone());

                    // Apply desired rotation (with reversed pitch)
                    this.cube.quaternion.copy(adjustedQuat);
                    this.cube.updateMatrixWorld(true);

                    // Compute pivot world position AFTER rotation and reposition the body so pivot stays at same X/Z and target Y
                    const pivotWorldAfter = this.cube.localToWorld(pivotLocal.clone());
                    const desiredPivotWorld = new THREE.Vector3(pivotWorldBefore.x, targetMinY, pivotWorldBefore.z);
                    const offset = new THREE.Vector3().subVectors(desiredPivotWorld, pivotWorldAfter);
                    this.cube.position.add(offset);
                    this.cube.updateMatrixWorld(true);

                    // Final clamp to guarantee contact (using all points)
                    if (this.contactLocalPoints && this.contactLocalPoints.length === 4) {
                        let finalMinY = Infinity;
                        for (let i = 0; i < 4; i++) {
                            const wp = this.cube.localToWorld(this.contactLocalPoints[i].clone());
                            if (wp.y < finalMinY) finalMinY = wp.y;
                        }
                        const delta = (groundY + epsilon) - finalMinY;
                        if (Math.abs(delta) > 1e-6) this.cube.position.y += delta;
                    }
                } else if (this.cube && !data.quaternion) {
                    // No IMU data, just apply the initial rotation offset
                    this.cube.quaternion.copy(this.initialRotationOffset);
                    console.warn('No quaternion data, using initial rotation only');
                }
                
                // Update gravity arrow direction
                if (this.showGravity && data.acceleration) {
                    const gravity = new THREE.Vector3(
                        data.acceleration.x,
                        data.acceleration.y,
                        data.acceleration.z
                    ).normalize();
                    
                    // Point arrow in direction of gravity
                    this.gravityArrow.lookAt(gravity);
                    this.gravityArrow.rotateX(Math.PI); // Flip to point down
                }
                } catch (error) {
                    console.error('Error in updateVisualization:', error);
                }
            }
            
            updateStatePill(state) {
                const pill = document.getElementById('statePill');
                pill.className = 'state-pill';
                
                switch (state) {
                    case 'still':
                        pill.classList.add('state-still');
                        pill.textContent = 'Still';
                        break;
                    case 'tilting':
                        pill.classList.add('state-tilting');
                        pill.textContent = 'Tilting';
                        break;
                    case 'aggressive':
                        pill.classList.add('state-aggressive');
                        pill.textContent = 'Aggressive Tilt';
                        break;
                    default:
                        pill.classList.add('state-no-signal');
                        pill.textContent = 'No Signal';
                }
            }
            
            showNoSignal() {
                document.getElementById('noSignalBanner').style.display = 'block';
            }
            
            hideNoSignal() {
                document.getElementById('noSignalBanner').style.display = 'none';
            }
            
            showCalibrating() {
                document.getElementById('calibratingBanner').style.display = 'block';
            }
            
            hideCalibrating() {
                document.getElementById('calibratingBanner').style.display = 'none';
            }
            
            setupEventListeners() {
                // Data panel toggle
                document.getElementById('dataToggleBtn').addEventListener('click', () => {
                    const sidebar = document.getElementById('sidebar');
                    sidebar.classList.toggle('visible');
                });
                
                // Settings panel toggle
                document.getElementById('settingsToggleBtn').addEventListener('click', () => {
                    const sidebar = document.getElementById('sidebar');
                    const panel = document.getElementById('advancedPanel');
                    
                    // Show sidebar if not visible
                    if (!sidebar.classList.contains('visible')) {
                        sidebar.classList.add('visible');
                    }
                    
                    // Toggle advanced panel
                    panel.classList.toggle('collapsed');
                });
                
                // Recalibrate button (hidden by default)
                document.getElementById('recalibrateBtn').addEventListener('click', () => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({ type: 'recalibrate' }));
                    }
                });
                
                // Settings change handlers
                const settingsInputs = [
                    'tiltThreshold', 'aggressiveThreshold', 
                    'rateThreshold', 'aggressiveRateThreshold', 
                    'smoothingTau'
                ];
                
                settingsInputs.forEach(id => {
                    document.getElementById(id).addEventListener('change', () => {
                        this.updateSettings();
                    });
                });
                
                // Checkbox handlers
                document.getElementById('showGravity').addEventListener('change', (e) => {
                    this.showGravity = e.target.checked;
                    this.gravityArrow.visible = this.showGravity;
                });
                
                document.getElementById('showAxes').addEventListener('change', (e) => {
                    this.showAxes = e.target.checked;
                    this.axes.visible = this.showAxes;
                });
            }
            
            updateSettings() {
                const settings = {
                    smoothingTau: parseFloat(document.getElementById('smoothingTau').value),
                    tiltThresholds: {
                        tilting: parseFloat(document.getElementById('tiltThreshold').value),
                        aggressive: parseFloat(document.getElementById('aggressiveThreshold').value)
                    },
                    rateThresholds: {
                        tilting: parseFloat(document.getElementById('rateThreshold').value),
                        aggressive: parseFloat(document.getElementById('aggressiveRateThreshold').value)
                    }
                };
                
                fetch('/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                }).catch(console.error);
            }
            
            onWindowResize() {
                const container = this.renderer.domElement.parentElement;
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                if (this.controls) this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize the viewer when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new IMUViewer();
        });
    </script>
</body>
</html>
